# This reusable workflow builds and publishes Docker images for mc-rtc-superbuild in three variants:
#
# 1. standalone-release: Minimal production image (~2-4GB) with install files + catkin workspaces
#    - Use case: Running controllers/simulators in production environments
#
# 2. standalone-devel: Full development image (~10-20GB) with sources + build + install + ccache
#    - Use case: Complete reproducible development environment with all build artifacts
#
# 3. devcontainer: VS Code devcontainer image (~1-2GB) with system packages + ccache
#    - Use case: Development with mounted source code and fast incremental builds
#
# The workflow optimizes build times by sharing the expensive build stage between standalone variants.

name: mc-rtc-superbuild packaging with Docker/Devcontainer

on:
  workflow_call:
    inputs:
      runner:
        required: false
        type: string
        default: ubuntu-24.04
        description: "Runner to use for the job."
      preset:
        type: string
        required: false
        default: relwithdebinfo

      custom-entrypoint-standalone:
        type: string
        required: false
        default: ''
        description: 'Path to a custom entrypoint script to include in the standalone image'

      build-args:
        type: string
        required: false
        default: ''
        description: 'Space-separated list of build-arg for docker. Ex "BUILD_VERSION=standalone KEEP_INSTALL=false"'

      build-standalone-release:
        type: boolean
        required: false
        default: true

      build-standalone-devel:
        type: boolean
        required: false
        default: true

      build-devcontainer:
        type: boolean
        required: false
        default: true

      repository:
        type: string
        description: "path to the superbuild repository to clone and package"
        required: false
        default: ''

      branch:
        type: string
        description: "superbuild branch to use"
        default: ''
        required: false

      free-disk-space:
        type: boolean
        required: false
        default: false

      container-repository:
        type: string
        required: true
        description: "Full path the the github container registry package path: ghcr.io/mc-rtc/mc-rtc-superbuild"

      push:
        type: boolean
        required: false
        default: true
        description: "Whether to push to the container-repository"

    secrets:
      SSH_KEY:
        description: "Private ssh key with access to clone the private repositories specified in the superbuild"
        required: false

jobs:
  reusable_workflow_job:
    permissions:
      contents: read
      packages: write
    runs-on: ${{ inputs.runner }}
    strategy:
      fail-fast: false
      matrix:
        # os: [jammy, noble]
        os: [jammy]
    env:
      SSH_KEY: ${{ secrets.SSH_KEY }}

    steps:
    - name: Dump github context
      env:
       GITHUB_CONTEXT: ${{ toJson(github) }}
      shell: bash
      run: |
        echo "$GITHUB_CONTEXT"

    # Configures ssh-agent if SSH_KEY secret exists
    - name: Configure ssh-agent
      if: ${{ env.SSH_KEY != '' }}
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_KEY }}

    - name: Check ssh-agent
      if: ${{ env.SSH_KEY != '' }}
      shell: bash
      run: |
          echo "SSH_AUTH_SOCK = ${{ env.SSH_AUTH_SOCK }}"
          ssh-add -l

    - name: Clone superbuild repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.branch }}
        ssh-key: ${{ env.SSH_KEY }}

    - name: Free Disk Space (Ubuntu)
      if: ${{ inputs.free-disk-space }}
      uses: jlumbroso/free-disk-space@main

    - name: Check docker
      shell: bash
      run: |
          docker ps

    - name: Check release
      shell: bash
      run: |
        if [ -n "${{ github.event.client_payload.tag }}" ]; then
          echo "This is a release, using version tag ${{ github.event.client_payload.tag }}"
          echo "RELEASE_TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_ENV
        else
          echo "This is not a release, using latest tag"
          echo "RELEASE_TAG=latest" >> $GITHUB_ENV
        fi

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup common docker build options
      shell: bash
      env:
        CONTAINER_NAME: ${{ inputs.container-repository }}
      run: |
        echo "CONTAINER_NAME: $CONTAINER_NAME"
        echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV

        if [ "${{ env.SSH_KEY }}" != '' ]; then
          SSH_OPT="--ssh default"
          echo "SSH_OPT=$SSH_OPT"
          echo "SSH_OPT=$SSH_OPT" >> $GITHUB_ENV;
        fi
        CMAKE_PRESET="${{ inputs.preset }}"
        if [ "${{ matrix.os }}" = "noble" ]; then
          echo "os is noble"
          CMAKE_PRESET=relwithdebinfo-noble
        else
          echo "os is not noble"
        fi
        echo "CMAKE_PRESET: $CMAKE_PRESET"
        echo "CMAKE_PRESET=$CMAKE_PRESET" >> $GITHUB_ENV
        echo "UBUNTU_VERSION=${{ matrix.os }}" >> $GITHUB_ENV

    - name: 'Docker: Build Standalone Images (Release + Devel)'
      if: ${{ inputs.build-standalone-release || inputs.build-standalone-devel }}
      env:
        CONTAINER_TAG_RELEASE: ${{ matrix.os }}-standalone-release-${{ env.RELEASE_TAG }}
        CONTAINER_TAG_DEVEL: ${{ matrix.os }}-standalone-devel-${{ env.RELEASE_TAG }}
      shell: bash
      run: |
        echo "::group::Prepare docker"

        CONTAINER_FULL_NAME_RELEASE=$CONTAINER_NAME:$CONTAINER_TAG_RELEASE
        CONTAINER_FULL_NAME_DEVEL=$CONTAINER_NAME:$CONTAINER_TAG_DEVEL
        echo "CONTAINER_FULL_NAME_RELEASE=$CONTAINER_FULL_NAME_RELEASE" >> $GITHUB_ENV
        echo "CONTAINER_FULL_NAME_DEVEL=$CONTAINER_FULL_NAME_DEVEL" >> $GITHUB_ENV
        echo "::endgroup::"

        echo "::group::Configuring build-args"
        BUILD_ARGS=""
        if [ ${{ inputs.custom-entrypoint-standalone }} != '' ]; then
          BUILD_ARGS="--build-arg CUSTOM_ENTRYPOINT=${{ inputs.custom-entrypoint-standalone }}"
        fi
        for arg in ${{ inputs.build-args }}; do
          BUILD_ARGS="$BUILD_ARGS --build-arg $arg"
        done
        echo "Extra build args: $BUILD_ARGS"
        echo "::endgroup::"

        echo "::group::Build Standalone Release Image"
        if [ "${{ inputs.build-standalone-release }}" = "true" ]; then
          docker build . -f .github/devcontainer/Dockerfile $SSH_OPT \
            --tag $CONTAINER_FULL_NAME_RELEASE \
            --target standalone-release \
            --build-arg CMAKE_PRESET=$CMAKE_PRESET \
            --build-arg BUILD_VERSION=standalone \
            --build-arg UBUNTU_VERSION="${{ matrix.os }}" \
            $BUILD_ARGS

          echo "Standalone Release image size:"
          docker inspect -f "{{ .Size }}" $CONTAINER_FULL_NAME_RELEASE | numfmt --to=si
        fi
        echo "::endgroup::"

        echo "::group::Build Standalone Devel Image"
        if [ "${{ inputs.build-standalone-devel }}" = "true" ]; then
          docker build . -f .github/devcontainer/Dockerfile $SSH_OPT \
            --tag $CONTAINER_FULL_NAME_DEVEL \
            --target standalone-devel \
            --build-arg CMAKE_PRESET=$CMAKE_PRESET \
            --build-arg BUILD_VERSION=standalone \
            --build-arg UBUNTU_VERSION="${{ matrix.os }}" \
            $BUILD_ARGS

          echo "Standalone Devel image size:"
          docker inspect -f "{{ .Size }}" $CONTAINER_FULL_NAME_DEVEL | numfmt --to=si
        fi
        echo "::endgroup::"

    - name: 'Docker: Push Standalone Images'
      if: ${{ (inputs.build-standalone-release || inputs.build-standalone-devel) && inputs.push }}
      shell: bash
      run: |
        if [ "${{ inputs.build-standalone-release }}" = "true" ]; then
          echo "Pushing standalone-release image..."
          docker push $CONTAINER_FULL_NAME_RELEASE
        fi

        if [ "${{ inputs.build-standalone-devel }}" = "true" ]; then
          echo "Pushing standalone-devel image..."
          docker push $CONTAINER_FULL_NAME_DEVEL
        fi

    - name: Free Disk Space (Ubuntu)
      if: ${{ inputs.free-disk-space && inputs.build-devcontainer}}
      uses: jlumbroso/free-disk-space@main

    - name: Setup Node.js
      if: ${{ inputs.build-devcontainer }}
      uses: actions/setup-node@v4
      with:
        node-version: 'latest'

    - name: Upgrade NPM
      if: ${{ inputs.build-devcontainer }}
      shell: bash
      run: |
        npm install -g npm@latest
        echo "Checking NPM vesion"
        npm -v

    - name: Configure devcontainer env
      if: ${{ inputs.build-devcontainer }}
      shell: bash
      run: |
        echo "DEVCONTAINER_NAME=${{ inputs.container-repository }}" >> $GITHUB_ENV
        echo "DEVCONTAINER_TAG=${{ matrix.os }}-devcontainer-${{ env.RELEASE_TAG }}" >> $GITHUB_ENV
        echo "DEVCONTAINER_FULL_NAME=$CONTAINER_NAME:${{ matrix.os }}-devcontainer-${{ env.RELEASE_TAG }}" >> $GITHUB_ENV

    - name: 'Docker: Build Devcontainer Image'
      if: ${{ inputs.build-devcontainer }}
      shell: bash
      run: |
        echo "::group::Build Devcontainer Image"
        docker build . -f .github/devcontainer/Dockerfile $SSH_OPT \
          --tag $DEVCONTAINER_FULL_NAME \
          --target devcontainer \
          --build-arg CMAKE_PRESET=$CMAKE_PRESET \
          --build-arg BUILD_VERSION=devcontainer \
          --build-arg UBUNTU_VERSION="${{ matrix.os }}"

        echo "Devcontainer image size:"
        docker inspect -f "{{ .Size }}" $DEVCONTAINER_FULL_NAME | numfmt --to=si
        echo "::endgroup::"

    - name: 'Docker: Push Devcontainer Image'
      if: ${{ inputs.build-devcontainer && inputs.push }}
      shell: bash
      run: |
        echo "Pushing devcontainer image..."
        docker push $DEVCONTAINER_FULL_NAME

    - name: 'Docker: Check all image sizes'
      shell: bash
      run: |
        echo "All built images:"
        docker images
